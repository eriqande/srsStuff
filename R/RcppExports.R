# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute covariance between individuals based on sampling a single read at each site
#'
#' This implements the covariance calculation method in ANGSD described at
#' \link{http://www.popgen.dk/angsd/index.php/PCA_MDS}, but it does it from
#' the allele depth information in a VCF file.  No need to go back to your BAMS, dude!
#'
#' This method only works on biallelic markers (but it can work on biallelic indels
#' if you have them).  You must do all the filtering you want to do on your VCF file
#' (using bcftools, for example) and then you have to extract the read depths from that
#' file and put it into a file on your hard drive somewhere.  That file is the
#' input to this function.
#'
#' If you had all your data in a VCF file called raw.vcf, here is how you would
#' process it:
#'
#' 1. Filter it.  Something like this to get biallelic markers typed at over 50\%
#' of individuals (i.e., having at least one read at over 50\% of individuals), and
#' with a minor allele frequency of > 0.05:
#'
#' \code{bcftools view -m 2 -M 2 --min-af 0.05 --max-af 0.95 -i 'F_MISSING < 0.5' raw.vcf > filtered.vcf}
#'
#' 2. Then extract the allele depths out of that. The will look like 0,1 or 2,1 or,
#' if they are missing, they will just be a dot, ".".   So, each row has 2 + N whitespace
#' separated values
#' on it, (where N is the number of individuals). The first two words on each row
#' are Chrom and Pos.  This assumes that the allele depths
#' are comma-separated, and that sites missing reads are denoted by a period:
#'
#' \code{bcftools query -f '\%CHROM\t\%POS[\t\%AD]\n' filtered.vcf > allele_depths.txt}
#'
#' 3. You might want to check that allele_depths has the right number of "words" in it.  So, you
#' would do \code{wc allele_depths.txt}, and confirm that the second number in the output
#' is equal to \eqn{(N + 2) * L}, where \eqn{N} is the number of individuals (samples)
#' in the data set, filtered.vcf, and \eqn{L} is the number of markers in filtered.vcf.
#' In other words, the file should have L rows, each one with N + 2 columns: 2 for Chrom and
#' Pos and then 1 column for each of the N individuals.
#'
#' 4. Then, you call this function, giving it the path to the file allele_depths.txt,
#' and you also pass in a vector of names for the individuals.
#' @param file path to the file that holds the Chrom, Pos, [AD] file (i.e. allele_depths.txt
#' in the description above).
#' @param sample_names A character vector of the names of the sample, in the
#' order they appear in the VCF file.
#' @param freq_thresh loci with the frequency of either allele estimated (by the fraction
#' of sampled single reads of each type) less than freq_thresh will not be used.
#'
#' @return This passes back a list that includes an N x N covariance matrix ($Cov); a martrix of
#' proportion of sampled reads identical by state between individuals ($IBS); a matrix of
#' number of sites having at least one read in both individuals of the pair ($M); the sample names,
#' the frequency threshold used in this function; and a report about the total number of loci
#' investigated and used.
#'
#'
#' @export
srs_covar <- function(file, sample_names, freq_thresh = 0.0) {
    .Call(`_srsStuff_srs_covar`, file, sample_names, freq_thresh)
}

#' Compute relative ibd measures from single read sampling
#'
#' This implements the calculations from the
#' "Unified Characterization of Population Structure
#' and Relatedness" framework of Weir and Goudet (2017), but it does it from
#' the allele depth information in a VCF file, by sampling a single
#' read from each individual.
#'
#' This method only works on biallelic markers (but it can work on biallelic indels
#' if you have them).  You must do all the filtering you want to do on your VCF file
#' (using bcftools, for example) and then you have to extract the read depths from that
#' file and put it into a file on your hard drive somewhere.  That file is the
#' input to this function.
#'
#' Note that it would not be too hard to modify this to deal with multiple alleles.
#'
#' If you had all your data in a VCF file called raw.vcf, here is how you would
#' process it:
#'
#' 1. Filter it.  Something like this to get biallelic markers typed at over 50\%
#' of individuals (i.e., having at least one read at over 50\% of individuals), and
#' with a minor allele frequency of > 0.05:
#'
#' \code{bcftools view -m 2 -M 2 --min-af 0.05 --max-af 0.95 -i 'F_MISSING < 0.5' raw.vcf > filtered.vcf}
#'
#' 2. Then extract the allele depths out of that. The will look like 0,1 or 2,1 or,
#' if they are missing, they will just be a dot, ".".   So, each row has 2 + N whitespace
#' separated values
#' on it, (where N is the number of individuals). The first two words on each row
#' are Chrom and Pos.  This assumes that the allele depths
#' are comma-separated, and that sites missing reads are denoted by a period:
#'
#' \code{bcftools query -f '\%CHROM\t\%POS[\t\%AD]\n' filtered.vcf > allele_depths.txt}
#'
#' 3. You might want to check that allele_depths has the right number of "words" in it.  So, you
#' would do \code{wc allele_depths.txt}, and confirm that the second number in the output
#' is equal to \eqn{(N + 2) * L}, where \eqn{N} is the number of individuals (samples)
#' in the data set, filtered.vcf, and \eqn{L} is the number of markers in filtered.vcf.
#' In other words, the file should have L rows, each one with N + 2 columns: 2 for Chrom and
#' Pos and then 1 column for each of the N individuals.
#'
#' 4. Then, you call this function, giving it the path to the file allele_depths.txt,
#' and you also pass in a list of vectors that hold information about the
#' hierarchical levels you want to use to be able to compute relative measures of
#' identity by descent.
#'
#' @param file path to the file that holds the Chrom, Pos, [AD] file (i.e. allele_depths.txt
#' in the description above).
#' @param pops_of_indivs a vector of 0-based indices of the populations each of the individuals
#' belongs to. Must be in the order that individuals appear in the VCF file.
#' @param num_pops The number of internal nodes in the tree that are directly above the individuals.
#' @param num_internal_nodes the number of internal nodes in the tree (this includes the populations)
#' @param daughters a list of vectors.  Each one is the 0-based indexes of the daughters
#' of the non-population internal nodes. Here 0 corresponds to the first internal node (the first population).
#' @param sample_names A character vector of the names of the sample, in the
#' order they appear in the VCF file.
#' @return This passes back a list of information about the various allele
#' sharing statistics (and, eventually bootstrap information) that can be
#' used by a higher-level function to compute the F-statistics, etc.
#'
#'
#' @export
srs_identity <- function(file, pops_of_indivs, num_pops, num_internal_nodes, daughters, sample_names, BootReps) {
    .Call(`_srsStuff_srs_identity`, file, pops_of_indivs, num_pops, num_internal_nodes, daughters, sample_names, BootReps)
}

